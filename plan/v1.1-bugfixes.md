# MailIt v1.1 — Bugfix & Polish Plan

Addresses all issues found during dogfood QA (8 issues) and the earlier grading audit.

## Issue Summary

| # | Issue | Severity | Root Cause | Phase |
|---|-------|----------|------------|-------|
| D-001 | Email rows not clickable | false positive | Dogfood tool limitation — `onRowClick` IS wired in DataTable | N/A |
| D-002 | Broadcasts page crashes (TypeError) | critical | Frontend expects `recipients`/`sent`/`audience_name`, backend sends `total_recipients`/`sent_count`/no audience_name | 2 |
| D-003 | Template rows not clickable | false positive | Same as D-001 — DataTable `onRowClick` works | N/A |
| D-004 | Audience dropdown empty | critical | `GET /audiences` returns bare `[...]`, frontend expects `{data: [...]}` | 1 |
| D-005 | API Keys shows empty | high | `GET /api-keys` returns bare `[...]`, frontend expects `{data: [...]}` | 1 |
| D-006 | Domain detail "not found" | high | `GET /domains/{id}` returns bare object `{...}`, frontend expects `{data: {...}}`; also field name mismatch `records` vs `dns_records` | 2 |
| D-007 | Logs shows empty | medium | Actually paginated — works. Logs just aren't populated (feature gap, not a bug) | N/A |
| D-008 | Metrics shows 0 sent | medium | Correct behavior — email failed delivery, so `sent: 0` is accurate | N/A |
| G-001 | Template detail API missing content | high | `TemplateResponse` lacks `subject`, `html`, `text`, `published`, `updated_at` | 3 |
| G-002 | 6 list endpoints return bare arrays | high | Services return `[]dto.XxxResponse` not wrapped | 1 |
| G-003 | Dockerfile Go version mismatch | low | `golang:1.23-alpine` should be `golang:1.25-alpine` | 4 |
| G-004 | docker-compose `version` deprecated | low | Both compose files have `version: '3.8'` | 4 |

**Real bugs to fix: 8** (D-002, D-004, D-005, D-006, G-001, G-002, G-003, G-004)
**False positives / working as designed: 4** (D-001, D-003, D-007, D-008)

---

## Phase 1: List Response Wrapping (6 endpoints)

**Problem**: 6 list endpoints return bare JSON arrays `[...]`. The frontend uniformly does `data?.data ?? []` expecting `{data: [...]}`.

**Fix**: Add a `ListResponse[T]` generic wrapper to the DTO layer and update 6 services + their interfaces.

### Step 1.1 — Add ListResponse to DTO

**File**: `internal/dto/pagination.go`

Add after the existing `PaginatedResponse`:
```go
type ListResponse[T any] struct {
    Data []T `json:"data"`
}
```

### Step 1.2 — Update 6 service return types

Each service's `List()` method changes from returning `([]dto.XxxResponse, error)` to `(*dto.ListResponse[dto.XxxResponse], error)`, and wraps the slice in the struct.

| File | Interface Method | Old Return | New Return |
|------|-----------------|------------|------------|
| `internal/service/audience.go` | `List(ctx, teamID)` | `([]dto.AudienceResponse, error)` | `(*dto.ListResponse[dto.AudienceResponse], error)` |
| `internal/service/apikey.go` | `List(ctx, teamID)` | `([]dto.APIKeyResponse, error)` | `(*dto.ListResponse[dto.APIKeyResponse], error)` |
| `internal/service/webhook.go` | `List(ctx, teamID)` | `([]dto.WebhookResponse, error)` | `(*dto.ListResponse[dto.WebhookResponse], error)` |
| `internal/service/topic.go` | `List(ctx, teamID)` | `([]dto.TopicResponse, error)` | `(*dto.ListResponse[dto.TopicResponse], error)` |
| `internal/service/contact_property.go` | `List(ctx, teamID)` | `([]dto.ContactPropertyResponse, error)` | `(*dto.ListResponse[dto.ContactPropertyResponse], error)` |
| `internal/service/segment.go` | `List(ctx, teamID, audienceID)` | `([]dto.SegmentResponse, error)` | `(*dto.ListResponse[dto.SegmentResponse], error)` |

For each, the implementation change is minimal — wrap the existing slice:
```go
// Before:
return data, nil

// After:
return &dto.ListResponse[dto.XxxResponse]{Data: data}, nil
```

### Step 1.3 — Update service interfaces

Each interface definition (at the top of each service file) must match the new return type.

### Step 1.4 — Update mock services

**File**: `internal/testutil/mock/services.go`

Update the 6 mock methods to match the new return types. Each mock's `List()` method changes its `.Get(0)` type assertion.

### Step 1.5 — Update handler tests

Any handler tests that reference the old return types need updated assertions.

**Verify**: `go build ./... && go test ./...`

---

## Phase 2: Field Name Mismatches (Broadcasts + Domain Detail)

### Step 2.1 — Broadcast response field names

**Problem**: Frontend expects `recipients`, `sent`, `audience_name`. Backend sends `total_recipients`, `sent_count`, no `audience_name`.

**File**: `internal/dto/broadcast.go`

Change `BroadcastResponse`:
```go
// Before:
TotalRecipients int     `json:"total_recipients"`
SentCount       int     `json:"sent_count"`

// After:
Recipients  int     `json:"recipients"`
Sent        int     `json:"sent"`
AudienceName *string `json:"audience_name,omitempty"`
```

**File**: `internal/service/broadcast.go`

Update `broadcastToResponse()` to:
- Map `model.Broadcast.TotalRecipients` → `dto.BroadcastResponse.Recipients`
- Map `model.Broadcast.SentCount` → `dto.BroadcastResponse.Sent`
- Look up audience name from the audience repository and include it

If the audience lookup is expensive for list operations, an alternative is to do a bulk-fetch of audience names. Check if the broadcast model already stores the audience name, or if a join is needed.

**Simpler alternative**: If adding the join is complex, just add `AudienceName` as empty for now and update the frontend to handle nil gracefully. The field name fixes (`recipients`, `sent`) are the critical part that fix the crash.

### Step 2.2 — Domain response field name + detail wrapping

**Problem 1**: Frontend expects `dns_records`, backend sends `records`.

**File**: `internal/dto/domain.go`

```go
// Before:
Records   []DNSRecordResponse `json:"records"`

// After:
DNSRecords []DNSRecordResponse `json:"dns_records"`
```

Then update all references to `Records` in the domain service to `DNSRecords`.

**Problem 2**: `GET /domains/{id}` returns bare `{id, name, status, ...}` but frontend expects `{data: {id, name, ...}}`.

**File**: `internal/handler/domain.go` — `Get()` method

Wrap the response:
```go
// Before:
pkg.JSON(w, http.StatusOK, resp)

// After:
pkg.JSON(w, http.StatusOK, map[string]interface{}{"data": resp})
```

Or better, use a generic wrapper:
```go
type SingleResponse[T any] struct {
    Data T `json:"data"`
}
```

**Note**: Check if other single-object GET endpoints need the same wrapping. The frontend pattern `data?.data` is used on domain detail. Verify if email detail and broadcast detail also use this pattern — if so, wrap those too.

### Step 2.3 — Update tests

Update any handler/service tests that assert on the old field names.

**Verify**: `go build ./... && go test ./...`

---

## Phase 3: Template Detail Response

**Problem**: `GET /templates/{id}` returns `{id, name, description, created_at}` — missing `subject`, `html`, `text`, `published`, `updated_at` that the frontend editor needs.

### Step 3.1 — Add TemplateDetailResponse DTO

**File**: `internal/dto/template.go`

```go
type TemplateDetailResponse struct {
    ID          string  `json:"id"`
    Name        string  `json:"name"`
    Description *string `json:"description,omitempty"`
    Subject     *string `json:"subject,omitempty"`
    HTML        *string `json:"html,omitempty"`
    Text        *string `json:"text,omitempty"`
    Published   bool    `json:"published"`
    CreatedAt   string  `json:"created_at"`
    UpdatedAt   string  `json:"updated_at"`
}
```

### Step 3.2 — Update TemplateService.Get() return type

**File**: `internal/service/template.go`

Change the interface:
```go
Get(ctx context.Context, teamID, templateID uuid.UUID) (*dto.TemplateDetailResponse, error)
```

Update the implementation to also fetch the latest template version:
```go
func (s *templateService) Get(ctx context.Context, teamID, templateID uuid.UUID) (*dto.TemplateDetailResponse, error) {
    template, err := s.templateRepo.GetByID(ctx, templateID)
    // ... team check ...

    latest, err := s.templateVersionRepo.GetLatestByTemplateID(ctx, template.ID)
    // ... handle error (might not have a version yet) ...

    return &dto.TemplateDetailResponse{
        ID:          template.ID.String(),
        Name:        template.Name,
        Description: template.Description,
        Subject:     latest.Subject,
        HTML:        latest.HTMLBody,
        Text:        latest.TextBody,
        Published:   latest.Published,
        CreatedAt:   template.CreatedAt.Format(time.RFC3339),
        UpdatedAt:   template.UpdatedAt.Format(time.RFC3339),
    }, nil
}
```

### Step 3.3 — Update mock and tests

Update the mock service in `internal/testutil/mock/services.go` and any template handler tests.

**Verify**: `go build ./... && go test ./...`

---

## Phase 4: Config / Infrastructure

### Step 4.1 — Dockerfile Go version

**File**: `deploy/docker/Dockerfile`

```dockerfile
# Before:
FROM golang:1.23-alpine AS builder

# After:
FROM golang:1.25-alpine AS builder
```

### Step 4.2 — Remove deprecated docker-compose version field

**Files**: `docker-compose.yml`, `docker-compose.dev.yml`

Remove the first line `version: '3.8'` from both files.

**Verify**: `docker compose -f docker-compose.dev.yml config 2>&1 | grep -i version` should produce no output.

---

## Phase 5: End-to-End Verification

1. Start postgres + redis via docker compose
2. Build and start Go server
3. Start Next.js dev server
4. Run the dogfood skill against localhost:3001
5. Verify:
   - Broadcasts page loads without crashing
   - Audience dropdown shows "Newsletter Subscribers"
   - API Keys page shows existing keys
   - Domain detail page loads with DNS records table
   - Template detail page shows subject/html/text content
6. Run `go test ./...` and `npx vitest run`
7. Stop everything

---

## Execution Order

Phases 1-4 can be done in sequence (each builds cleanly on prior state). Phase 5 is the final validation.

| Phase | Effort | Files Changed | Tests Changed |
|-------|--------|---------------|---------------|
| 1: List wrapping | ~30 min | 7 Go files (1 DTO + 6 services) + interfaces + mocks | ~6 mock methods |
| 2: Field mismatches | ~30 min | 3 Go files (broadcast DTO + domain DTO + domain handler) + service | ~4 tests |
| 3: Template detail | ~20 min | 2 Go files (DTO + service) + mock | ~2 tests |
| 4: Config/infra | ~5 min | 3 files (Dockerfile + 2 compose) | 0 |
| 5: E2E verify | ~15 min | 0 | 0 |
| **Total** | **~1.5 hr** | **~15 files** | **~12 test updates** |
